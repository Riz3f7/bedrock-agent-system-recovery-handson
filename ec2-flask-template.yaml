AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template to deploy a Flask application on Amazon Linux 2023 with Session Manager access'

Parameters:
  InstanceType:
    Description: EC2 instance type
    Type: String
    Default: t3.micro
    AllowedValues:
      - t3.micro
      - t3.small
      - t3.medium
    ConstraintDescription: Must be a valid EC2 instance type.
    
  VpcId:
    Description: VPC where the EC2 instance will be deployed
    Type: AWS::EC2::VPC::Id
    
  SubnetId:
    Description: Public subnet ID where the EC2 instance will be deployed
    Type: AWS::EC2::Subnet::Id

Resources:
  FlaskAppSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable HTTP access
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0

  FlaskAppRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
      Path: /

  FlaskAppInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref FlaskAppRole

  # Step 3: Lambda Functions for Bedrock Agent
  BedrockAgentLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CloudWatchLogsReadPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                  - logs:FilterLogEvents
                  - logs:GetLogEvents
                Resource: '*'
        - PolicyName: EC2ManagementPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeInstances
                  - ec2:DescribeInstanceStatus
                  - ec2:RebootInstances
                  - ec2:DescribeTags
                Resource: '*'

  GetLogLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: get-log
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt BedrockAgentLambdaRole.Arn
      Timeout: 300
      MemorySize: 512
      Code:
        ZipFile: |
          """
          CloudWatch Logs 取得 Lambda 関数
          Claude 3.5/4 Sonnet 最適化
          """
          
          import boto3
          import json
          import time
          from datetime import datetime, timedelta
          from typing import Dict, List, Any, Optional, Union
          from dataclasses import dataclass
          import re
          from botocore.exceptions import ClientError, BotoCoreError
          
          @dataclass
          class LogEntry:
              """ログエントリのデータクラス"""
              timestamp: int
              log_stream_name: str
              message: str
              severity: str
              instance_id: Optional[str] = None
              error_type: Optional[str] = None
          
          class CloudWatchLogsClient:
              """CloudWatch Logs クライアントのラッパークラス"""
              
              def __init__(self):
                  self.client = boto3.client('logs')
                  self.instance_id_pattern = re.compile(r'i-[a-f0-9]{8,17}')
                  self.error_patterns = {
                      'ERROR': re.compile(r'ERROR|Error|error'),
                      'CRITICAL': re.compile(r'CRITICAL|Critical|critical|FATAL|Fatal|fatal'),
                      'WARNING': re.compile(r'WARNING|Warning|warning|WARN|Warn|warn'),
                      'EXCEPTION': re.compile(r'Exception|exception|Traceback|traceback')
                  }
              
              def get_log_streams(self, log_group_name: str, limit: int = 50) -> List[Dict[str, Any]]:
                  """ログストリームの一覧を取得"""
                  try:
                      response = self.client.describe_log_streams(
                          logGroupName=log_group_name,
                          orderBy='LastEventTime',
                          descending=True,
                          limit=limit
                      )
                      return response.get('logStreams', [])
                  except ClientError as e:
                      raise Exception(f"Failed to get log streams: {e}")
              
              def get_log_events(self, log_group_name: str, log_stream_name: str, 
                                start_time: int, end_time: int) -> List[Dict[str, Any]]:
                  """ログイベントを取得"""
                  try:
                      response = self.client.get_log_events(
                          logGroupName=log_group_name,
                          logStreamName=log_stream_name,
                          startTime=start_time,
                          endTime=end_time,
                          startFromHead=False
                      )
                      return response.get('events', [])
                  except ClientError as e:
                      print(f"Warning: Failed to get events from stream {log_stream_name}: {e}")
                      return []
              
              def filter_log_events(self, log_group_name: str, start_time: int, end_time: int,
                                   filter_pattern: str = '?ERROR ?Exception ?Traceback') -> List[Dict[str, Any]]:
                  """フィルターパターンを使用してログイベントを効率的に取得"""
                  try:
                      all_events = []
                      next_token = None
                      max_iterations = 10  # 無限ループ防止
                      iteration = 0
                      
                      while iteration < max_iterations:
                          kwargs = {
                              'logGroupName': log_group_name,
                              'startTime': start_time,
                              'endTime': end_time,
                              'filterPattern': filter_pattern,
                              'limit': 1000  # 一度に取得する最大イベント数
                          }
                          
                          if next_token:
                              kwargs['nextToken'] = next_token
                          
                          response = self.client.filter_log_events(**kwargs)
                          events = response.get('events', [])
                          all_events.extend(events)
                          
                          next_token = response.get('nextToken')
                          if not next_token:
                              break
                              
                          iteration += 1
                      
                      return all_events
                  except ClientError as e:
                      print(f"Warning: Failed to filter log events: {e}")
                      return []
          
          class LogAnalyzer:
              """ログ分析クラス"""
              
              def __init__(self):
                  self.instance_id_pattern = re.compile(r'i-[a-f0-9]{8,17}')
                  self.error_patterns = {
                      'CRITICAL': [
                          re.compile(r'CRITICAL|Critical|critical|FATAL|Fatal|fatal'),
                          re.compile(r'OutOfMemoryError|MemoryError'),
                          re.compile(r'ConnectionRefusedError|ConnectionError'),
                          re.compile(r'TimeoutError|timeout')
                      ],
                      'ERROR': [
                          re.compile(r'ERROR|Error(?!.*warning)'),
                          re.compile(r'Exception(?!.*test)'),
                          re.compile(r'Traceback'),
                          re.compile(r'Failed|failed(?!.*warning)')
                      ],
                      'WARNING': [
                          re.compile(r'WARNING|Warning|warning|WARN|Warn|warn'),
                          re.compile(r'deprecated|Deprecated')
                      ]
                  }
              
              def extract_instance_id(self, message: str) -> Optional[str]:
                  """メッセージからインスタンスIDを抽出"""
                  match = self.instance_id_pattern.search(message)
                  return match.group(0) if match else None
              
              def determine_severity(self, message: str) -> str:
                  """メッセージの重要度を判定"""
                  message_lower = message.lower()
                  
                  # 重要度の高い順にチェック
                  for severity, patterns in self.error_patterns.items():
                      for pattern in patterns:
                          if pattern.search(message):
                              return severity
                  
                  return 'INFO'
              
              def extract_error_type(self, message: str) -> Optional[str]:
                  """エラータイプを抽出"""
                  # 一般的なPythonの例外タイプ
                  exception_patterns = [
                      r'(\w+Error)',
                      r'(\w+Exception)',
                      r'(TimeoutError)',
                      r'(ConnectionError)',
                      r'(ValueError)',
                      r'(TypeError)',
                      r'(AttributeError)',
                      r'(KeyError)',
                      r'(IndexError)'
                  ]
                  
                  for pattern in exception_patterns:
                      match = re.search(pattern, message)
                      if match:
                          return match.group(1)
                  
                  return None
              
              def is_error_log(self, message: str) -> bool:
                  """エラーログかどうかを判定"""
                  severity = self.determine_severity(message)
                  return severity in ['ERROR', 'CRITICAL', 'WARNING']
              
              def analyze_log_entry(self, event: Dict[str, Any], log_stream_name: str) -> LogEntry:
                  """ログエントリを分析"""
                  message = event['message']
                  severity = self.determine_severity(message)
                  instance_id = self.extract_instance_id(message)
                  error_type = self.extract_error_type(message) if severity in ['ERROR', 'CRITICAL'] else None
                  
                  return LogEntry(
                      timestamp=event['timestamp'],
                      log_stream_name=log_stream_name,
                      message=message,
                      severity=severity,
                      instance_id=instance_id,
                      error_type=error_type
                  )
          
          class LogRetriever:
              """ログ取得メインクラス"""
              
              def __init__(self):
                  self.cloudwatch_client = CloudWatchLogsClient()
                  self.analyzer = LogAnalyzer()
              
              def get_error_logs(self, log_group_name: str, hours_ago: int = 24, 
                                filter_pattern: str = '?ERROR ?Exception ?Traceback') -> Dict[str, Any]:
                  """エラーログを取得して分析（フィルターパターン使用）"""
                  try:
                      end_time = int(time.time() * 1000)
                      start_time = end_time - (hours_ago * 60 * 60 * 1000)
                      
                      # フィルターパターンを使用してエラーログを直接取得
                      filtered_events = self.cloudwatch_client.filter_log_events(
                          log_group_name, start_time, end_time, filter_pattern
                      )
                      
                      if not filtered_events:
                          return {
                              'status': 'no_errors',
                              'message': f'No error logs found in {log_group_name} for the past {hours_ago} hours',
                              'error_logs': [],
                              'summary': self._create_empty_summary()
                          }
                      
                      error_logs = []
                      log_stream_names = set()
                      
                      for event in filtered_events:
                          log_stream_name = event.get('logStreamName', 'unknown')
                          log_stream_names.add(log_stream_name)
                          
                          # ログエントリを分析
                          log_entry = self.analyzer.analyze_log_entry(event, log_stream_name)
                          
                          error_logs.append({
                              'timestamp': log_entry.timestamp,
                              'datetime': datetime.fromtimestamp(log_entry.timestamp / 1000).isoformat(),
                              'logStreamName': log_entry.log_stream_name,
                              'message': log_entry.message,
                              'severity': log_entry.severity,
                              'instanceId': log_entry.instance_id,
                              'errorType': log_entry.error_type
                          })
                      
                      # 結果をタイムスタンプでソート（新しい順）
                      error_logs.sort(key=lambda x: x['timestamp'], reverse=True)
                      
                      return {
                          'status': 'success',
                          'error_logs': error_logs,
                          'summary': self._create_summary(error_logs, len(log_stream_names), hours_ago),
                          'metadata': {
                              'log_group': log_group_name,
                              'time_range_hours': hours_ago,
                              'processed_streams': len(log_stream_names),
                              'filter_pattern': filter_pattern,
                              'query_time': datetime.utcnow().isoformat()
                          }
                      }
                      
                  except Exception as e:
                      return {
                          'status': 'error',
                          'error': str(e),
                          'error_logs': [],
                          'summary': self._create_empty_summary()
                      }
              
              def _create_summary(self, error_logs: List[Dict], processed_streams: int, hours_ago: int) -> Dict[str, Any]:
                  """エラーログのサマリーを作成"""
                  if not error_logs:
                      return self._create_empty_summary()
                  
                  # 重要度別の集計
                  severity_counts = {}
                  error_type_counts = {}
                  instance_ids = set()
                  
                  for log in error_logs:
                      # 重要度別カウント
                      severity = log['severity']
                      severity_counts[severity] = severity_counts.get(severity, 0) + 1
                      
                      # エラータイプ別カウント
                      error_type = log.get('errorType')
                      if error_type:
                          error_type_counts[error_type] = error_type_counts.get(error_type, 0) + 1
                      
                      # インスタンスID収集
                      instance_id = log.get('instanceId')
                      if instance_id:
                          instance_ids.add(instance_id)
                  
                  # 最新のエラー
                  latest_error = error_logs[0] if error_logs else None
                  
                  return {
                      'total_errors': len(error_logs),
                      'severity_breakdown': severity_counts,
                      'error_types': error_type_counts,
                      'affected_instances': list(instance_ids),
                      'latest_error': {
                          'timestamp': latest_error['datetime'],
                          'severity': latest_error['severity'],
                          'message': latest_error['message'][:200] + '...' if len(latest_error['message']) > 200 else latest_error['message']
                      } if latest_error else None,
                      'time_range_hours': hours_ago,
                      'processed_streams': processed_streams
                  }
              
              def _create_empty_summary(self) -> Dict[str, Any]:
                  """空のサマリーを作成"""
                  return {
                      'total_errors': 0,
                      'severity_breakdown': {},
                      'error_types': {},
                      'affected_instances': [],
                      'latest_error': None,
                      'time_range_hours': 0,
                      'processed_streams': 0
                  }
          
          def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
              """Lambda関数のエントリーポイント"""
              print(f"Received event: {json.dumps(event, ensure_ascii=False)}")
              
              # デフォルト値
              log_group_name = '/aws/ec2/my-flask-application'
              hours_ago = 24
              
              try:
                  # パラメータの取得
                  if 'parameters' in event:
                      for param in event['parameters']:
                          if param['name'] == 'logGroup':
                              log_group_name = param['value']
                          elif param['name'] == 'hoursAgo':
                              hours_ago = int(param['value'])
                  
                  # ログ取得の実行
                  log_retriever = LogRetriever()
                  result = log_retriever.get_error_logs(log_group_name, hours_ago)
                  
                  # レスポンスの構築
                  response = {
                      "messageVersion": "1.0",
                      "response": {
                          "actionGroup": event.get("actionGroup", ""),
                          "apiPath": event.get("apiPath", ""),
                          "httpMethod": event.get("httpMethod", ""),
                          "httpStatusCode": 200,
                          "responseBody": {
                              "application/json": {
                                  "body": result
                              }
                          }
                      }
                  }
                  
                  print(f"Response: {json.dumps(response, ensure_ascii=False)}")
                  return response
                  
              except Exception as e:
                  error_response = {
                      "messageVersion": "1.0",
                      "response": {
                          "actionGroup": event.get("actionGroup", ""),
                          "apiPath": event.get("apiPath", ""),
                          "httpMethod": event.get("httpMethod", ""),
                          "httpStatusCode": 500,
                          "responseBody": {
                              "application/json": {
                                  "body": {
                                      "status": "error",
                                      "error": str(e),
                                      "error_logs": [],
                                      "summary": {
                                          "total_errors": 0,
                                          "severity_breakdown": {},
                                          "error_types": {},
                                          "affected_instances": [],
                                          "latest_error": None
                                      }
                                  }
                              }
                          }
                      }
                  }
                  
                  print(f"Error response: {json.dumps(error_response, ensure_ascii=False)}")
                  return error_response

  RebootInstancesLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: reboot-instances
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt BedrockAgentLambdaRole.Arn
      Timeout: 300
      MemorySize: 512
      Code:
        ZipFile: |
          """
          EC2 インスタンス再起動 Lambda 関数
          Claude 3.5/4 Sonnet 最適化
          """
          
          import boto3
          import json
          from datetime import datetime
          from typing import Dict, List, Any, Optional, Union
          from dataclasses import dataclass
          from botocore.exceptions import ClientError, BotoCoreError
          import time
          
          @dataclass
          class InstanceInfo:
              """インスタンス情報のデータクラス"""
              instance_id: str
              state: str
              instance_type: str
              availability_zone: str
              launch_time: Optional[str] = None
              tags: Optional[Dict[str, str]] = None
          
          class EC2Client:
              """EC2 クライアントのラッパークラス"""
              
              def __init__(self):
                  self.client = boto3.client('ec2')
              
              def get_instance_info(self, instance_id: str) -> Optional[InstanceInfo]:
                  """インスタンス情報を取得"""
                  try:
                      response = self.client.describe_instances(InstanceIds=[instance_id])
                      
                      if not response['Reservations']:
                          return None
                      
                      instance = response['Reservations'][0]['Instances'][0]
                      
                      # タグを辞書形式に変換
                      tags = {}
                      if 'Tags' in instance:
                          tags = {tag['Key']: tag['Value'] for tag in instance['Tags']}
                      
                      return InstanceInfo(
                          instance_id=instance['InstanceId'],
                          state=instance['State']['Name'],
                          instance_type=instance['InstanceType'],
                          availability_zone=instance['Placement']['AvailabilityZone'],
                          launch_time=instance.get('LaunchTime', '').isoformat() if instance.get('LaunchTime') else None,
                          tags=tags
                      )
                      
                  except ClientError as e:
                      print(f"Error getting instance info for {instance_id}: {e}")
                      return None
              
              def reboot_instance(self, instance_id: str, dry_run: bool = False) -> Dict[str, Any]:
                  """インスタンスを再起動"""
                  try:
                      response = self.client.reboot_instances(
                          InstanceIds=[instance_id], 
                          DryRun=dry_run
                      )
                      
                      return {
                          'success': True,
                          'message': f'Successfully initiated reboot for instance {instance_id}',
                          'response_metadata': response.get('ResponseMetadata', {})
                      }
                      
                  except ClientError as e:
                      error_code = e.response['Error']['Code']
                      error_message = e.response['Error']['Message']
                      
                      if error_code == 'DryRunOperation':
                          return {
                              'success': True,
                              'message': f'Dry run successful for instance {instance_id}',
                              'dry_run': True
                          }
                      elif error_code == 'InvalidInstanceID.NotFound':
                          return {
                              'success': False,
                              'error': f'Instance {instance_id} not found',
                              'error_code': error_code
                          }
                      elif error_code == 'IncorrectInstanceState':
                          return {
                              'success': False,
                              'error': f'Instance {instance_id} is in incorrect state for reboot',
                              'error_code': error_code
                          }
                      else:
                          return {
                              'success': False,
                              'error': f'Failed to reboot instance {instance_id}: {error_message}',
                              'error_code': error_code
                          }
                  except Exception as e:
                      return {
                          'success': False,
                          'error': f'Unexpected error rebooting instance {instance_id}: {str(e)}'
                      }
          
          class InstanceValidator:
              """インスタンス検証クラス"""
              
              def __init__(self, ec2_client: EC2Client):
                  self.ec2_client = ec2_client
              
              def validate_instance_id(self, instance_id: str) -> Dict[str, Any]:
                  """インスタンスIDの形式と存在を検証"""
                  # インスタンスIDの形式チェック
                  if not instance_id or not instance_id.startswith('i-'):
                      return {
                          'valid': False,
                          'error': f'Invalid instance ID format: {instance_id}. Must start with "i-"'
                      }
                  
                  if len(instance_id) < 10:
                      return {
                          'valid': False,
                          'error': f'Invalid instance ID length: {instance_id}'
                      }
                  
                  # インスタンスの存在確認
                  instance_info = self.ec2_client.get_instance_info(instance_id)
                  if not instance_info:
                      return {
                          'valid': False,
                          'error': f'Instance {instance_id} not found'
                      }
                  
                  return {
                      'valid': True,
                      'instance_info': instance_info
                  }
              
              def can_reboot_instance(self, instance_info: InstanceInfo) -> Dict[str, Any]:
                  """インスタンスが再起動可能かチェック"""
                  rebootable_states = ['running', 'stopped']
                  
                  if instance_info.state not in rebootable_states:
                      return {
                          'can_reboot': False,
                          'reason': f'Instance is in state "{instance_info.state}". Can only reboot instances in states: {rebootable_states}'
                      }
                  
                  # 特定のタグによる制限チェック（例：本番環境の保護）
                  if instance_info.tags:
                      environment = instance_info.tags.get('Environment', '').lower()
                      if environment == 'production':
                          protection = instance_info.tags.get('RebootProtection', '').lower()
                          if protection == 'enabled':
                              return {
                                  'can_reboot': False,
                                  'reason': 'Instance has reboot protection enabled (RebootProtection=enabled tag)'
                              }
                  
                  return {
                      'can_reboot': True,
                      'reason': 'Instance is in valid state for reboot'
                  }
          
          class RebootManager:
              """再起動管理メインクラス"""
              
              def __init__(self):
                  self.ec2_client = EC2Client()
                  self.validator = InstanceValidator(self.ec2_client)
              
              def reboot_instance_with_validation(self, instance_id: str, 
                                                force: bool = False,
                                                dry_run: bool = False) -> Dict[str, Any]:
                  """検証付きインスタンス再起動"""
                  operation_start = datetime.utcnow()
                  
                  try:
                      # インスタンスIDの検証
                      validation_result = self.validator.validate_instance_id(instance_id)
                      if not validation_result['valid']:
                          return {
                              'success': False,
                              'error': validation_result['error'],
                              'operation_time': datetime.utcnow().isoformat(),
                              'instance_id': instance_id
                          }
                      
                      instance_info = validation_result['instance_info']
                      
                      # 再起動可能性のチェック
                      if not force:
                          reboot_check = self.validator.can_reboot_instance(instance_info)
                          if not reboot_check['can_reboot']:
                              return {
                                  'success': False,
                                  'error': reboot_check['reason'],
                                  'operation_time': datetime.utcnow().isoformat(),
                                  'instance_id': instance_id,
                                  'instance_state': instance_info.state
                              }
                      
                      # 再起動の実行
                      reboot_result = self.ec2_client.reboot_instance(instance_id, dry_run)
                      
                      if not reboot_result['success']:
                          return {
                              'success': False,
                              'error': reboot_result['error'],
                              'operation_time': datetime.utcnow().isoformat(),
                              'instance_id': instance_id,
                              'instance_state': instance_info.state
                          }
                      
                      # 成功レスポンス
                      response = {
                          'success': True,
                          'message': reboot_result['message'],
                          'operation_time': datetime.utcnow().isoformat(),
                          'instance_id': instance_id,
                          'instance_info': {
                              'state': instance_info.state,
                              'instance_type': instance_info.instance_type,
                              'availability_zone': instance_info.availability_zone,
                              'tags': instance_info.tags
                          }
                      }
                      
                      if dry_run:
                          response['dry_run'] = True
                          response['message'] = f'Dry run successful - would reboot instance {instance_id}'
                      
                      return response
                      
                  except Exception as e:
                      return {
                          'success': False,
                          'error': f'Unexpected error during reboot operation: {str(e)}',
                          'operation_time': datetime.utcnow().isoformat(),
                          'instance_id': instance_id
                      }
          
          def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
              """Lambda関数のエントリーポイント"""
              print(f"Received event: {json.dumps(event, ensure_ascii=False)}")
              
              try:
                  # パラメータの取得
                  instance_id = None
                  force = False
                  dry_run = False
                  
                  if 'parameters' in event:
                      for param in event['parameters']:
                          if param['name'] == 'instanceId':
                              instance_id = param['value']
                          elif param['name'] == 'force':
                              force = param['value'].lower() == 'true'
                          elif param['name'] == 'dryRun':
                              dry_run = param['value'].lower() == 'true'
                  
                  # 必須パラメータのチェック
                  if not instance_id:
                      return create_error_response(
                          event, 400, 
                          'Missing required parameter: instanceId'
                      )
                  
                  # 再起動の実行
                  reboot_manager = RebootManager()
                  result = reboot_manager.reboot_instance_with_validation(
                      instance_id, force=force, dry_run=dry_run
                  )
                  
                  # レスポンスの構築
                  if result['success']:
                      return create_success_response(event, result)
                  else:
                      return create_error_response(event, 400, result['error'], result)
                      
              except Exception as e:
                  print(f"Unexpected error in lambda_handler: {e}")
                  return create_error_response(
                      event, 500, 
                      f'Internal server error: {str(e)}'
                  )
          
          def create_success_response(event: Dict[str, Any], result: Dict[str, Any]) -> Dict[str, Any]:
              """成功レスポンスを作成"""
              return {
                  "messageVersion": "1.0",
                  "response": {
                      "actionGroup": event.get("actionGroup", ""),
                      "apiPath": event.get("apiPath", ""),
                      "httpMethod": event.get("httpMethod", ""),
                      "httpStatusCode": 200,
                      "responseBody": {
                          "application/json": {
                              "body": result
                          }
                      }
                  }
              }
          
          def create_error_response(event: Dict[str, Any], status_code: int, 
                                   error_message: str, additional_data: Dict[str, Any] = None) -> Dict[str, Any]:
              """エラーレスポンスを作成"""
              error_body = {
                  'success': False,
                  'error': error_message,
                  'timestamp': datetime.utcnow().isoformat()
              }
              
              if additional_data:
                  error_body.update(additional_data)
              
              return {
                  "messageVersion": "1.0",
                  "response": {
                      "actionGroup": event.get("actionGroup", ""),
                      "apiPath": event.get("apiPath", ""),
                      "httpMethod": event.get("httpMethod", ""),
                      "httpStatusCode": status_code,
                      "responseBody": {
                          "application/json": {
                              "body": error_body
                          }
                      }
                  }
              }

  FlaskAppInstance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      IamInstanceProfile: !Ref FlaskAppInstanceProfile
      ImageId: !FindInMap [RegionMap, !Ref 'AWS::Region', AL2023AMI]
      MetadataOptions:
        HttpTokens: optional  # IMDSv1を有効化（トークン不要）
        HttpEndpoint: enabled
      NetworkInterfaces:
        - AssociatePublicIpAddress: true
          DeviceIndex: 0
          SubnetId: !Ref SubnetId
          GroupSet:
            - !Ref FlaskAppSecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          # Update system packages
          dnf update -y
          
          # Install Python and pip (curl and wget are already installed)
          dnf install -y python3 python3-pip
          
          # Install required Python packages
          pip3 install flask requests
          
          # Create application directory
          mkdir -p /opt/flask-app
          
          # Download application code from S3
          wget -O /opt/flask-app/app.py https://handson-resource-yamamugi.s3.amazonaws.com/jawsug/202507handson/app-optimized.py
          
          # Create systemd service file
          cat > /etc/systemd/system/flask-app.service << 'EOL'
          [Unit]
          Description=Flask Application Service
          After=network.target

          [Service]
          User=root
          WorkingDirectory=/opt/flask-app
          ExecStart=/usr/bin/python3 /opt/flask-app/app.py
          Restart=always
          Environment=PORT=80
          Environment=FLASK_DEBUG=False

          [Install]
          WantedBy=multi-user.target
          EOL
          
          # Install CloudWatch Agent
          dnf install -y amazon-cloudwatch-agent
          
          # Configure CloudWatch Agent
          cat > /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json << 'EOL'
          {
            "agent": {
              "metrics_collection_interval": 60,
              "run_as_user": "root"
            },
            "logs": {
              "logs_collected": {
                "files": {
                  "collect_list": [
                    {
                      "file_path": "/var/log/my-flask-app.log",
                      "log_group_name": "/aws/ec2/my-flask-application",
                      "log_stream_name": "{instance_id}",
                      "retention_in_days": 14
                    }
                  ]
                }
              }
            }
          }
          EOL
          
          # Start CloudWatch Agent
          systemctl enable amazon-cloudwatch-agent
          systemctl start amazon-cloudwatch-agent
          
          # Enable and start the Flask application
          systemctl daemon-reload
          systemctl enable flask-app
          systemctl start flask-app

  # Resource-based policies for Bedrock Agent access
  GetLogLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref GetLogLambda
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*

  RebootInstancesLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref RebootInstancesLambda
      Action: lambda:InvokeFunction
      Principal: bedrock.amazonaws.com
      SourceArn: !Sub arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:agent/*

Mappings:
  RegionMap:
    us-east-1:
      AL2023AMI: ami-05c13eab67c5d8861
    us-east-2:
      AL2023AMI: ami-0e83be366243f524a
    us-west-1:
      AL2023AMI: ami-0ce2cb35386fc22e9
    us-west-2:
      AL2023AMI: ami-0b75c1e8f5c9b860a
    ap-northeast-1:
      AL2023AMI: ami-0d52744dc1592a3a4
    ap-northeast-2:
      AL2023AMI: ami-0f3a440bbcff3d043
    ap-southeast-1:
      AL2023AMI: ami-0fb7b398d3ee1c9ab
    ap-southeast-2:
      AL2023AMI: ami-0d6f74b9139d26623
    eu-west-1:
      AL2023AMI: ami-0e23c576dacf2e3df
    eu-central-1:
      AL2023AMI: ami-0faab6bdbac9486fb

Outputs:
  InstanceId:
    Description: The Instance ID
    Value: !Ref FlaskAppInstance
  PublicIP:
    Description: Public IP address of the EC2 instance
    Value: !GetAtt FlaskAppInstance.PublicIp
  WebsiteURL:
    Description: URL for the Flask application
    Value: !Sub http://${FlaskAppInstance.PublicDnsName}
  SessionManagerURL:
    Description: URL to connect to the instance using Session Manager
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/systems-manager/session-manager/${FlaskAppInstance}
  LogGroupURL:
    Description: URL to the CloudWatch Logs group
    Value: !Sub https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#logsV2:log-groups/log-group/$252Faws$252Fec2$252Fmy-flask-application
  GetLogLambdaArn:
    Description: ARN of the Get Log Lambda Function
    Value: !GetAtt GetLogLambda.Arn
  RebootInstancesLambdaArn:
    Description: ARN of the Reboot Instances Lambda Function
    Value: !GetAtt RebootInstancesLambda.Arn
  BedrockAgentLambdaRoleArn:
    Description: ARN of the Bedrock Agent Lambda Role
    Value: !GetAtt BedrockAgentLambdaRole.Arn